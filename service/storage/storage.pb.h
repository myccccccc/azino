// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/storage/storage.proto

#ifndef PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED
#define PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "service/kv.pb.h"
// @@protoc_insertion_point(includes)

namespace azino {
namespace storage {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

class BatchStoreRequest;
class BatchStoreResponse;
class DeleteRequest;
class DeleteResponse;
class GetRequest;
class GetResponse;
class MVCCDeleteRequest;
class MVCCDeleteResponse;
class MVCCGetRequest;
class MVCCGetResponse;
class MVCCPutRequest;
class MVCCPutResponse;
class MVCCScanRequest;
class MVCCScanResponse;
class PutRequest;
class PutResponse;
class StorageStatus;
class StoreData;

enum StorageStatus_Code {
  StorageStatus_Code_Ok = 0,
  StorageStatus_Code_NotFound = 1,
  StorageStatus_Code_Corruption = 2,
  StorageStatus_Code_NotSupported = 3,
  StorageStatus_Code_InvalidArgument = 4,
  StorageStatus_Code_IOError = 5
};
bool StorageStatus_Code_IsValid(int value);
const StorageStatus_Code StorageStatus_Code_Code_MIN = StorageStatus_Code_Ok;
const StorageStatus_Code StorageStatus_Code_Code_MAX = StorageStatus_Code_IOError;
const int StorageStatus_Code_Code_ARRAYSIZE = StorageStatus_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* StorageStatus_Code_descriptor();
inline const ::std::string& StorageStatus_Code_Name(StorageStatus_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    StorageStatus_Code_descriptor(), value);
}
inline bool StorageStatus_Code_Parse(
    const ::std::string& name, StorageStatus_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StorageStatus_Code>(
    StorageStatus_Code_descriptor(), name, value);
}
// ===================================================================

class StorageStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.StorageStatus) */ {
 public:
  StorageStatus();
  virtual ~StorageStatus();

  StorageStatus(const StorageStatus& from);

  inline StorageStatus& operator=(const StorageStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageStatus& default_instance();

  void Swap(StorageStatus* other);

  // implements Message ----------------------------------------------

  inline StorageStatus* New() const { return New(NULL); }

  StorageStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageStatus& from);
  void MergeFrom(const StorageStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StorageStatus_Code Code;
  static const Code Ok =
    StorageStatus_Code_Ok;
  static const Code NotFound =
    StorageStatus_Code_NotFound;
  static const Code Corruption =
    StorageStatus_Code_Corruption;
  static const Code NotSupported =
    StorageStatus_Code_NotSupported;
  static const Code InvalidArgument =
    StorageStatus_Code_InvalidArgument;
  static const Code IOError =
    StorageStatus_Code_IOError;
  static inline bool Code_IsValid(int value) {
    return StorageStatus_Code_IsValid(value);
  }
  static const Code Code_MIN =
    StorageStatus_Code_Code_MIN;
  static const Code Code_MAX =
    StorageStatus_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    StorageStatus_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return StorageStatus_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return StorageStatus_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return StorageStatus_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus.Code error_code = 1 [default = Ok];
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::azino::storage::StorageStatus_Code error_code() const;
  void set_error_code(::azino::storage::StorageStatus_Code value);

  // optional string error_message = 2;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:azino.storage.StorageStatus)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  int error_code_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static StorageStatus* default_instance_;
};
// -------------------------------------------------------------------

class PutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.PutRequest) */ {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutRequest& default_instance();

  void Swap(PutRequest* other);

  // implements Message ----------------------------------------------

  inline PutRequest* New() const { return New(NULL); }

  PutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:azino.storage.PutRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static PutRequest* default_instance_;
};
// -------------------------------------------------------------------

class PutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.PutResponse) */ {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutResponse& default_instance();

  void Swap(PutResponse* other);

  // implements Message ----------------------------------------------

  inline PutResponse* New() const { return New(NULL); }

  PutResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.PutResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static PutResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  void Swap(GetRequest* other);

  // implements Message ----------------------------------------------

  inline GetRequest* New() const { return New(NULL); }

  GetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:azino.storage.GetRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();

  void Swap(GetResponse* other);

  // implements Message ----------------------------------------------

  inline GetResponse* New() const { return New(NULL); }

  GetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .azino.storage.StorageStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.GetResponse)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  void Swap(DeleteRequest* other);

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const { return New(NULL); }

  DeleteRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:azino.storage.DeleteRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();

  void Swap(DeleteResponse* other);

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const { return New(NULL); }

  DeleteResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.DeleteResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class MVCCPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCPutRequest) */ {
 public:
  MVCCPutRequest();
  virtual ~MVCCPutRequest();

  MVCCPutRequest(const MVCCPutRequest& from);

  inline MVCCPutRequest& operator=(const MVCCPutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCPutRequest& default_instance();

  void Swap(MVCCPutRequest* other);

  // implements Message ----------------------------------------------

  inline MVCCPutRequest* New() const { return New(NULL); }

  MVCCPutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCPutRequest& from);
  void MergeFrom(const MVCCPutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional uint64 ts = 3;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 3;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCPutRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint64 ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCPutRequest* default_instance_;
};
// -------------------------------------------------------------------

class MVCCPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCPutResponse) */ {
 public:
  MVCCPutResponse();
  virtual ~MVCCPutResponse();

  MVCCPutResponse(const MVCCPutResponse& from);

  inline MVCCPutResponse& operator=(const MVCCPutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCPutResponse& default_instance();

  void Swap(MVCCPutResponse* other);

  // implements Message ----------------------------------------------

  inline MVCCPutResponse* New() const { return New(NULL); }

  MVCCPutResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCPutResponse& from);
  void MergeFrom(const MVCCPutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCPutResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCPutResponse* default_instance_;
};
// -------------------------------------------------------------------

class MVCCGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCGetRequest) */ {
 public:
  MVCCGetRequest();
  virtual ~MVCCGetRequest();

  MVCCGetRequest(const MVCCGetRequest& from);

  inline MVCCGetRequest& operator=(const MVCCGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCGetRequest& default_instance();

  void Swap(MVCCGetRequest* other);

  // implements Message ----------------------------------------------

  inline MVCCGetRequest* New() const { return New(NULL); }

  MVCCGetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCGetRequest& from);
  void MergeFrom(const MVCCGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional uint64 ts = 2;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 2;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCGetRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class MVCCGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCGetResponse) */ {
 public:
  MVCCGetResponse();
  virtual ~MVCCGetResponse();

  MVCCGetResponse(const MVCCGetResponse& from);

  inline MVCCGetResponse& operator=(const MVCCGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCGetResponse& default_instance();

  void Swap(MVCCGetResponse* other);

  // implements Message ----------------------------------------------

  inline MVCCGetResponse* New() const { return New(NULL); }

  MVCCGetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCGetResponse& from);
  void MergeFrom(const MVCCGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .azino.storage.StorageStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // optional uint64 ts = 3;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 3;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCGetResponse)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::azino::storage::StorageStatus* status_;
  ::google::protobuf::uint64 ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class MVCCDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCDeleteRequest) */ {
 public:
  MVCCDeleteRequest();
  virtual ~MVCCDeleteRequest();

  MVCCDeleteRequest(const MVCCDeleteRequest& from);

  inline MVCCDeleteRequest& operator=(const MVCCDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCDeleteRequest& default_instance();

  void Swap(MVCCDeleteRequest* other);

  // implements Message ----------------------------------------------

  inline MVCCDeleteRequest* New() const { return New(NULL); }

  MVCCDeleteRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCDeleteRequest& from);
  void MergeFrom(const MVCCDeleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional uint64 ts = 2;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 2;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCDeleteRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCDeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class MVCCDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCDeleteResponse) */ {
 public:
  MVCCDeleteResponse();
  virtual ~MVCCDeleteResponse();

  MVCCDeleteResponse(const MVCCDeleteResponse& from);

  inline MVCCDeleteResponse& operator=(const MVCCDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCDeleteResponse& default_instance();

  void Swap(MVCCDeleteResponse* other);

  // implements Message ----------------------------------------------

  inline MVCCDeleteResponse* New() const { return New(NULL); }

  MVCCDeleteResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCDeleteResponse& from);
  void MergeFrom(const MVCCDeleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCDeleteResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCDeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class StoreData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.StoreData) */ {
 public:
  StoreData();
  virtual ~StoreData();

  StoreData(const StoreData& from);

  inline StoreData& operator=(const StoreData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreData& default_instance();

  void Swap(StoreData* other);

  // implements Message ----------------------------------------------

  inline StoreData* New() const { return New(NULL); }

  StoreData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreData& from);
  void MergeFrom(const StoreData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StoreData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional uint64 ts = 2;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 2;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // optional .azino.Value value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::azino::Value& value() const;
  ::azino::Value* mutable_value();
  ::azino::Value* release_value();
  void set_allocated_value(::azino::Value* value);

  // @@protoc_insertion_point(class_scope:azino.storage.StoreData)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 ts_;
  ::azino::Value* value_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static StoreData* default_instance_;
};
// -------------------------------------------------------------------

class BatchStoreRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.BatchStoreRequest) */ {
 public:
  BatchStoreRequest();
  virtual ~BatchStoreRequest();

  BatchStoreRequest(const BatchStoreRequest& from);

  inline BatchStoreRequest& operator=(const BatchStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchStoreRequest& default_instance();

  void Swap(BatchStoreRequest* other);

  // implements Message ----------------------------------------------

  inline BatchStoreRequest* New() const { return New(NULL); }

  BatchStoreRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchStoreRequest& from);
  void MergeFrom(const BatchStoreRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchStoreRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .azino.storage.StoreData datas = 1;
  int datas_size() const;
  void clear_datas();
  static const int kDatasFieldNumber = 1;
  const ::azino::storage::StoreData& datas(int index) const;
  ::azino::storage::StoreData* mutable_datas(int index);
  ::azino::storage::StoreData* add_datas();
  ::google::protobuf::RepeatedPtrField< ::azino::storage::StoreData >*
      mutable_datas();
  const ::google::protobuf::RepeatedPtrField< ::azino::storage::StoreData >&
      datas() const;

  // @@protoc_insertion_point(class_scope:azino.storage.BatchStoreRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::azino::storage::StoreData > datas_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static BatchStoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class BatchStoreResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.BatchStoreResponse) */ {
 public:
  BatchStoreResponse();
  virtual ~BatchStoreResponse();

  BatchStoreResponse(const BatchStoreResponse& from);

  inline BatchStoreResponse& operator=(const BatchStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchStoreResponse& default_instance();

  void Swap(BatchStoreResponse* other);

  // implements Message ----------------------------------------------

  inline BatchStoreResponse* New() const { return New(NULL); }

  BatchStoreResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchStoreResponse& from);
  void MergeFrom(const BatchStoreResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchStoreResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.storage.StorageStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // @@protoc_insertion_point(class_scope:azino.storage.BatchStoreResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::storage::StorageStatus* status_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static BatchStoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class MVCCScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCScanRequest) */ {
 public:
  MVCCScanRequest();
  virtual ~MVCCScanRequest();

  MVCCScanRequest(const MVCCScanRequest& from);

  inline MVCCScanRequest& operator=(const MVCCScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCScanRequest& default_instance();

  void Swap(MVCCScanRequest* other);

  // implements Message ----------------------------------------------

  inline MVCCScanRequest* New() const { return New(NULL); }

  MVCCScanRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCScanRequest& from);
  void MergeFrom(const MVCCScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string left_key = 1;
  bool has_left_key() const;
  void clear_left_key();
  static const int kLeftKeyFieldNumber = 1;
  const ::std::string& left_key() const;
  void set_left_key(const ::std::string& value);
  void set_left_key(const char* value);
  void set_left_key(const char* value, size_t size);
  ::std::string* mutable_left_key();
  ::std::string* release_left_key();
  void set_allocated_left_key(::std::string* left_key);

  // optional string right_key = 2;
  bool has_right_key() const;
  void clear_right_key();
  static const int kRightKeyFieldNumber = 2;
  const ::std::string& right_key() const;
  void set_right_key(const ::std::string& value);
  void set_right_key(const char* value);
  void set_right_key(const char* value, size_t size);
  ::std::string* mutable_right_key();
  ::std::string* release_right_key();
  void set_allocated_right_key(::std::string* right_key);

  // optional uint64 ts = 3;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 3;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCScanRequest)
 private:
  inline void set_has_left_key();
  inline void clear_has_left_key();
  inline void set_has_right_key();
  inline void clear_has_right_key();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr left_key_;
  ::google::protobuf::internal::ArenaStringPtr right_key_;
  ::google::protobuf::uint64 ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class MVCCScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.storage.MVCCScanResponse) */ {
 public:
  MVCCScanResponse();
  virtual ~MVCCScanResponse();

  MVCCScanResponse(const MVCCScanResponse& from);

  inline MVCCScanResponse& operator=(const MVCCScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVCCScanResponse& default_instance();

  void Swap(MVCCScanResponse* other);

  // implements Message ----------------------------------------------

  inline MVCCScanResponse* New() const { return New(NULL); }

  MVCCScanResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVCCScanResponse& from);
  void MergeFrom(const MVCCScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MVCCScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string key = 1;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key(int index) const;
  ::std::string* mutable_key(int index);
  void set_key(int index, const ::std::string& value);
  void set_key(int index, const char* value);
  void set_key(int index, const char* value, size_t size);
  ::std::string* add_key();
  void add_key(const ::std::string& value);
  void add_key(const char* value);
  void add_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // optional .azino.storage.StorageStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::azino::storage::StorageStatus& status() const;
  ::azino::storage::StorageStatus* mutable_status();
  ::azino::storage::StorageStatus* release_status();
  void set_allocated_status(::azino::storage::StorageStatus* status);

  // repeated uint64 ts = 4;
  int ts_size() const;
  void clear_ts();
  static const int kTsFieldNumber = 4;
  ::google::protobuf::uint64 ts(int index) const;
  void set_ts(int index, ::google::protobuf::uint64 value);
  void add_ts(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ts();

  // @@protoc_insertion_point(class_scope:azino.storage.MVCCScanResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  ::azino::storage::StorageStatus* status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ts_;
  friend void  protobuf_AddDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_AssignDesc_service_2fstorage_2fstorage_2eproto();
  friend void protobuf_ShutdownFile_service_2fstorage_2fstorage_2eproto();

  void InitAsDefaultInstance();
  static MVCCScanResponse* default_instance_;
};
// ===================================================================

class StorageService_Stub;

class StorageService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline StorageService() {};
 public:
  virtual ~StorageService();

  typedef StorageService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void MVCCPut(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCPutRequest* request,
                       ::azino::storage::MVCCPutResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void MVCCGet(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCGetRequest* request,
                       ::azino::storage::MVCCGetResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void MVCCDelete(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCDeleteRequest* request,
                       ::azino::storage::MVCCDeleteResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void MVCCScan(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCScanRequest* request,
                       ::azino::storage::MVCCScanResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void BatchStore(::google::protobuf::RpcController* controller,
                       const ::azino::storage::BatchStoreRequest* request,
                       ::azino::storage::BatchStoreResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StorageService);
};

class StorageService_Stub : public StorageService {
 public:
  StorageService_Stub(::google::protobuf::RpcChannel* channel);
  StorageService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~StorageService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements StorageService ------------------------------------------

  void MVCCPut(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCPutRequest* request,
                       ::azino::storage::MVCCPutResponse* response,
                       ::google::protobuf::Closure* done);
  void MVCCGet(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCGetRequest* request,
                       ::azino::storage::MVCCGetResponse* response,
                       ::google::protobuf::Closure* done);
  void MVCCDelete(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCDeleteRequest* request,
                       ::azino::storage::MVCCDeleteResponse* response,
                       ::google::protobuf::Closure* done);
  void MVCCScan(::google::protobuf::RpcController* controller,
                       const ::azino::storage::MVCCScanRequest* request,
                       ::azino::storage::MVCCScanResponse* response,
                       ::google::protobuf::Closure* done);
  void BatchStore(::google::protobuf::RpcController* controller,
                       const ::azino::storage::BatchStoreRequest* request,
                       ::azino::storage::BatchStoreResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StorageService_Stub);
};


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// StorageStatus

// optional .azino.storage.StorageStatus.Code error_code = 1 [default = Ok];
inline bool StorageStatus::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageStatus::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageStatus::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageStatus::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::azino::storage::StorageStatus_Code StorageStatus::error_code() const {
  // @@protoc_insertion_point(field_get:azino.storage.StorageStatus.error_code)
  return static_cast< ::azino::storage::StorageStatus_Code >(error_code_);
}
inline void StorageStatus::set_error_code(::azino::storage::StorageStatus_Code value) {
  assert(::azino::storage::StorageStatus_Code_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.StorageStatus.error_code)
}

// optional string error_message = 2;
inline bool StorageStatus::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageStatus::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageStatus::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageStatus::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& StorageStatus::error_message() const {
  // @@protoc_insertion_point(field_get:azino.storage.StorageStatus.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageStatus::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.StorageStatus.error_message)
}
inline void StorageStatus::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.StorageStatus.error_message)
}
inline void StorageStatus::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.StorageStatus.error_message)
}
inline ::std::string* StorageStatus::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:azino.storage.StorageStatus.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageStatus::release_error_message() {
  // @@protoc_insertion_point(field_release:azino.storage.StorageStatus.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageStatus::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.StorageStatus.error_message)
}

// -------------------------------------------------------------------

// PutRequest

// optional string key = 1;
inline bool PutRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.PutRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.PutRequest.key)
}
inline void PutRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.PutRequest.key)
}
inline void PutRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.PutRequest.key)
}
inline ::std::string* PutRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.PutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.PutRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.PutRequest.key)
}

// optional string value = 2;
inline bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:azino.storage.PutRequest.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.PutRequest.value)
}
inline void PutRequest::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.PutRequest.value)
}
inline void PutRequest::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.PutRequest.value)
}
inline ::std::string* PutRequest::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:azino.storage.PutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:azino.storage.PutRequest.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// optional .azino.storage.StorageStatus status = 1;
inline bool PutResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& PutResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.PutResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* PutResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.PutResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* PutResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.PutResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void PutResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.PutResponse.status)
}

// -------------------------------------------------------------------

// GetRequest

// optional string key = 1;
inline bool GetRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.GetRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.GetRequest.key)
}
inline void GetRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.GetRequest.key)
}
inline void GetRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.GetRequest.key)
}
inline ::std::string* GetRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.GetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.GetRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.GetRequest.key)
}

// -------------------------------------------------------------------

// GetResponse

// optional string value = 1;
inline bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:azino.storage.GetResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetResponse::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.GetResponse.value)
}
inline void GetResponse::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.GetResponse.value)
}
inline void GetResponse::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.GetResponse.value)
}
inline ::std::string* GetResponse::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:azino.storage.GetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:azino.storage.GetResponse.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.GetResponse.value)
}

// optional .azino.storage.StorageStatus status = 2;
inline bool GetResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& GetResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.GetResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* GetResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.GetResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* GetResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.GetResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.GetResponse.status)
}

// -------------------------------------------------------------------

// DeleteRequest

// optional string key = 1;
inline bool DeleteRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.DeleteRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.DeleteRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.DeleteRequest.key)
}

// -------------------------------------------------------------------

// DeleteResponse

// optional .azino.storage.StorageStatus status = 1;
inline bool DeleteResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& DeleteResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.DeleteResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* DeleteResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.DeleteResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* DeleteResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.DeleteResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void DeleteResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.DeleteResponse.status)
}

// -------------------------------------------------------------------

// MVCCPutRequest

// optional string key = 1;
inline bool MVCCPutRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCPutRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCPutRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCPutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& MVCCPutRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCPutRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCPutRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCPutRequest.key)
}
inline void MVCCPutRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCPutRequest.key)
}
inline void MVCCPutRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCPutRequest.key)
}
inline ::std::string* MVCCPutRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCPutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCPutRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCPutRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCPutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCPutRequest.key)
}

// optional string value = 2;
inline bool MVCCPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVCCPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVCCPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVCCPutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& MVCCPutRequest::value() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCPutRequest.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCPutRequest::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCPutRequest.value)
}
inline void MVCCPutRequest::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCPutRequest.value)
}
inline void MVCCPutRequest::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCPutRequest.value)
}
inline ::std::string* MVCCPutRequest::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCPutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCPutRequest.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCPutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCPutRequest.value)
}

// optional uint64 ts = 3;
inline bool MVCCPutRequest::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVCCPutRequest::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVCCPutRequest::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVCCPutRequest::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 MVCCPutRequest::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCPutRequest.ts)
  return ts_;
}
inline void MVCCPutRequest::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.MVCCPutRequest.ts)
}

// -------------------------------------------------------------------

// MVCCPutResponse

// optional .azino.storage.StorageStatus status = 1;
inline bool MVCCPutResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCPutResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCPutResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCPutResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& MVCCPutResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCPutResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* MVCCPutResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCPutResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* MVCCPutResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCPutResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void MVCCPutResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCPutResponse.status)
}

// -------------------------------------------------------------------

// MVCCGetRequest

// optional string key = 1;
inline bool MVCCGetRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCGetRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCGetRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& MVCCGetRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCGetRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCGetRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCGetRequest.key)
}
inline void MVCCGetRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCGetRequest.key)
}
inline void MVCCGetRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCGetRequest.key)
}
inline ::std::string* MVCCGetRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCGetRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCGetRequest.key)
}

// optional uint64 ts = 2;
inline bool MVCCGetRequest::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVCCGetRequest::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVCCGetRequest::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVCCGetRequest::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 MVCCGetRequest::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCGetRequest.ts)
  return ts_;
}
inline void MVCCGetRequest::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.MVCCGetRequest.ts)
}

// -------------------------------------------------------------------

// MVCCGetResponse

// optional string value = 1;
inline bool MVCCGetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCGetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCGetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCGetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& MVCCGetResponse::value() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCGetResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCGetResponse::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCGetResponse.value)
}
inline void MVCCGetResponse::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCGetResponse.value)
}
inline void MVCCGetResponse::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCGetResponse.value)
}
inline ::std::string* MVCCGetResponse::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCGetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCGetResponse.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCGetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCGetResponse.value)
}

// optional .azino.storage.StorageStatus status = 2;
inline bool MVCCGetResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVCCGetResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVCCGetResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVCCGetResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& MVCCGetResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCGetResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* MVCCGetResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCGetResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* MVCCGetResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCGetResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void MVCCGetResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCGetResponse.status)
}

// optional uint64 ts = 3;
inline bool MVCCGetResponse::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVCCGetResponse::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVCCGetResponse::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVCCGetResponse::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 MVCCGetResponse::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCGetResponse.ts)
  return ts_;
}
inline void MVCCGetResponse::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.MVCCGetResponse.ts)
}

// -------------------------------------------------------------------

// MVCCDeleteRequest

// optional string key = 1;
inline bool MVCCDeleteRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCDeleteRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCDeleteRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCDeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& MVCCDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCDeleteRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCDeleteRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCDeleteRequest.key)
}
inline void MVCCDeleteRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCDeleteRequest.key)
}
inline void MVCCDeleteRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCDeleteRequest.key)
}
inline ::std::string* MVCCDeleteRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCDeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCDeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCDeleteRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCDeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCDeleteRequest.key)
}

// optional uint64 ts = 2;
inline bool MVCCDeleteRequest::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVCCDeleteRequest::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVCCDeleteRequest::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVCCDeleteRequest::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 MVCCDeleteRequest::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCDeleteRequest.ts)
  return ts_;
}
inline void MVCCDeleteRequest::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.MVCCDeleteRequest.ts)
}

// -------------------------------------------------------------------

// MVCCDeleteResponse

// optional .azino.storage.StorageStatus status = 1;
inline bool MVCCDeleteResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCDeleteResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCDeleteResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCDeleteResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& MVCCDeleteResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCDeleteResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* MVCCDeleteResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCDeleteResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* MVCCDeleteResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCDeleteResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void MVCCDeleteResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCDeleteResponse.status)
}

// -------------------------------------------------------------------

// StoreData

// optional string key = 1;
inline bool StoreData::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreData::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreData::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& StoreData::key() const {
  // @@protoc_insertion_point(field_get:azino.storage.StoreData.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StoreData::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.StoreData.key)
}
inline void StoreData::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.StoreData.key)
}
inline void StoreData::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.StoreData.key)
}
inline ::std::string* StoreData::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.StoreData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StoreData::release_key() {
  // @@protoc_insertion_point(field_release:azino.storage.StoreData.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StoreData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.StoreData.key)
}

// optional uint64 ts = 2;
inline bool StoreData::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreData::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreData::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreData::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 StoreData::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.StoreData.ts)
  return ts_;
}
inline void StoreData::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.StoreData.ts)
}

// optional .azino.Value value = 3;
inline bool StoreData::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreData::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreData::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreData::clear_value() {
  if (value_ != NULL) value_->::azino::Value::Clear();
  clear_has_value();
}
inline const ::azino::Value& StoreData::value() const {
  // @@protoc_insertion_point(field_get:azino.storage.StoreData.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::azino::Value* StoreData::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::azino::Value;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.StoreData.value)
  return value_;
}
inline ::azino::Value* StoreData::release_value() {
  // @@protoc_insertion_point(field_release:azino.storage.StoreData.value)
  clear_has_value();
  ::azino::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void StoreData::set_allocated_value(::azino::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.StoreData.value)
}

// -------------------------------------------------------------------

// BatchStoreRequest

// repeated .azino.storage.StoreData datas = 1;
inline int BatchStoreRequest::datas_size() const {
  return datas_.size();
}
inline void BatchStoreRequest::clear_datas() {
  datas_.Clear();
}
inline const ::azino::storage::StoreData& BatchStoreRequest::datas(int index) const {
  // @@protoc_insertion_point(field_get:azino.storage.BatchStoreRequest.datas)
  return datas_.Get(index);
}
inline ::azino::storage::StoreData* BatchStoreRequest::mutable_datas(int index) {
  // @@protoc_insertion_point(field_mutable:azino.storage.BatchStoreRequest.datas)
  return datas_.Mutable(index);
}
inline ::azino::storage::StoreData* BatchStoreRequest::add_datas() {
  // @@protoc_insertion_point(field_add:azino.storage.BatchStoreRequest.datas)
  return datas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::azino::storage::StoreData >*
BatchStoreRequest::mutable_datas() {
  // @@protoc_insertion_point(field_mutable_list:azino.storage.BatchStoreRequest.datas)
  return &datas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::azino::storage::StoreData >&
BatchStoreRequest::datas() const {
  // @@protoc_insertion_point(field_list:azino.storage.BatchStoreRequest.datas)
  return datas_;
}

// -------------------------------------------------------------------

// BatchStoreResponse

// optional .azino.storage.StorageStatus status = 1;
inline bool BatchStoreResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchStoreResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchStoreResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchStoreResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& BatchStoreResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.BatchStoreResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* BatchStoreResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.BatchStoreResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* BatchStoreResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.BatchStoreResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void BatchStoreResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.BatchStoreResponse.status)
}

// -------------------------------------------------------------------

// MVCCScanRequest

// optional string left_key = 1;
inline bool MVCCScanRequest::has_left_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVCCScanRequest::set_has_left_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVCCScanRequest::clear_has_left_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVCCScanRequest::clear_left_key() {
  left_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_left_key();
}
inline const ::std::string& MVCCScanRequest::left_key() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanRequest.left_key)
  return left_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCScanRequest::set_left_key(const ::std::string& value) {
  set_has_left_key();
  left_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanRequest.left_key)
}
inline void MVCCScanRequest::set_left_key(const char* value) {
  set_has_left_key();
  left_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCScanRequest.left_key)
}
inline void MVCCScanRequest::set_left_key(const char* value, size_t size) {
  set_has_left_key();
  left_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCScanRequest.left_key)
}
inline ::std::string* MVCCScanRequest::mutable_left_key() {
  set_has_left_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCScanRequest.left_key)
  return left_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCScanRequest::release_left_key() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCScanRequest.left_key)
  clear_has_left_key();
  return left_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCScanRequest::set_allocated_left_key(::std::string* left_key) {
  if (left_key != NULL) {
    set_has_left_key();
  } else {
    clear_has_left_key();
  }
  left_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), left_key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCScanRequest.left_key)
}

// optional string right_key = 2;
inline bool MVCCScanRequest::has_right_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVCCScanRequest::set_has_right_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVCCScanRequest::clear_has_right_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVCCScanRequest::clear_right_key() {
  right_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_right_key();
}
inline const ::std::string& MVCCScanRequest::right_key() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanRequest.right_key)
  return right_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCScanRequest::set_right_key(const ::std::string& value) {
  set_has_right_key();
  right_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanRequest.right_key)
}
inline void MVCCScanRequest::set_right_key(const char* value) {
  set_has_right_key();
  right_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCScanRequest.right_key)
}
inline void MVCCScanRequest::set_right_key(const char* value, size_t size) {
  set_has_right_key();
  right_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCScanRequest.right_key)
}
inline ::std::string* MVCCScanRequest::mutable_right_key() {
  set_has_right_key();
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCScanRequest.right_key)
  return right_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MVCCScanRequest::release_right_key() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCScanRequest.right_key)
  clear_has_right_key();
  return right_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MVCCScanRequest::set_allocated_right_key(::std::string* right_key) {
  if (right_key != NULL) {
    set_has_right_key();
  } else {
    clear_has_right_key();
  }
  right_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), right_key);
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCScanRequest.right_key)
}

// optional uint64 ts = 3;
inline bool MVCCScanRequest::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVCCScanRequest::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVCCScanRequest::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVCCScanRequest::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 MVCCScanRequest::ts() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanRequest.ts)
  return ts_;
}
inline void MVCCScanRequest::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanRequest.ts)
}

// -------------------------------------------------------------------

// MVCCScanResponse

// repeated string key = 1;
inline int MVCCScanResponse::key_size() const {
  return key_.size();
}
inline void MVCCScanResponse::clear_key() {
  key_.Clear();
}
inline const ::std::string& MVCCScanResponse::key(int index) const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanResponse.key)
  return key_.Get(index);
}
inline ::std::string* MVCCScanResponse::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCScanResponse.key)
  return key_.Mutable(index);
}
inline void MVCCScanResponse::set_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanResponse.key)
  key_.Mutable(index)->assign(value);
}
inline void MVCCScanResponse::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCScanResponse.key)
}
inline void MVCCScanResponse::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCScanResponse.key)
}
inline ::std::string* MVCCScanResponse::add_key() {
  // @@protoc_insertion_point(field_add_mutable:azino.storage.MVCCScanResponse.key)
  return key_.Add();
}
inline void MVCCScanResponse::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:azino.storage.MVCCScanResponse.key)
}
inline void MVCCScanResponse::add_key(const char* value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:azino.storage.MVCCScanResponse.key)
}
inline void MVCCScanResponse::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:azino.storage.MVCCScanResponse.key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MVCCScanResponse::key() const {
  // @@protoc_insertion_point(field_list:azino.storage.MVCCScanResponse.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MVCCScanResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:azino.storage.MVCCScanResponse.key)
  return &key_;
}

// repeated string value = 2;
inline int MVCCScanResponse::value_size() const {
  return value_.size();
}
inline void MVCCScanResponse::clear_value() {
  value_.Clear();
}
inline const ::std::string& MVCCScanResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanResponse.value)
  return value_.Get(index);
}
inline ::std::string* MVCCScanResponse::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCScanResponse.value)
  return value_.Mutable(index);
}
inline void MVCCScanResponse::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanResponse.value)
  value_.Mutable(index)->assign(value);
}
inline void MVCCScanResponse::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:azino.storage.MVCCScanResponse.value)
}
inline void MVCCScanResponse::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:azino.storage.MVCCScanResponse.value)
}
inline ::std::string* MVCCScanResponse::add_value() {
  // @@protoc_insertion_point(field_add_mutable:azino.storage.MVCCScanResponse.value)
  return value_.Add();
}
inline void MVCCScanResponse::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:azino.storage.MVCCScanResponse.value)
}
inline void MVCCScanResponse::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:azino.storage.MVCCScanResponse.value)
}
inline void MVCCScanResponse::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:azino.storage.MVCCScanResponse.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MVCCScanResponse::value() const {
  // @@protoc_insertion_point(field_list:azino.storage.MVCCScanResponse.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MVCCScanResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:azino.storage.MVCCScanResponse.value)
  return &value_;
}

// optional .azino.storage.StorageStatus status = 3;
inline bool MVCCScanResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVCCScanResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVCCScanResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVCCScanResponse::clear_status() {
  if (status_ != NULL) status_->::azino::storage::StorageStatus::Clear();
  clear_has_status();
}
inline const ::azino::storage::StorageStatus& MVCCScanResponse::status() const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::azino::storage::StorageStatus* MVCCScanResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::azino::storage::StorageStatus;
  }
  // @@protoc_insertion_point(field_mutable:azino.storage.MVCCScanResponse.status)
  return status_;
}
inline ::azino::storage::StorageStatus* MVCCScanResponse::release_status() {
  // @@protoc_insertion_point(field_release:azino.storage.MVCCScanResponse.status)
  clear_has_status();
  ::azino::storage::StorageStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void MVCCScanResponse::set_allocated_status(::azino::storage::StorageStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.storage.MVCCScanResponse.status)
}

// repeated uint64 ts = 4;
inline int MVCCScanResponse::ts_size() const {
  return ts_.size();
}
inline void MVCCScanResponse::clear_ts() {
  ts_.Clear();
}
inline ::google::protobuf::uint64 MVCCScanResponse::ts(int index) const {
  // @@protoc_insertion_point(field_get:azino.storage.MVCCScanResponse.ts)
  return ts_.Get(index);
}
inline void MVCCScanResponse::set_ts(int index, ::google::protobuf::uint64 value) {
  ts_.Set(index, value);
  // @@protoc_insertion_point(field_set:azino.storage.MVCCScanResponse.ts)
}
inline void MVCCScanResponse::add_ts(::google::protobuf::uint64 value) {
  ts_.Add(value);
  // @@protoc_insertion_point(field_add:azino.storage.MVCCScanResponse.ts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MVCCScanResponse::ts() const {
  // @@protoc_insertion_point(field_list:azino.storage.MVCCScanResponse.ts)
  return ts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MVCCScanResponse::mutable_ts() {
  // @@protoc_insertion_point(field_mutable_list:azino.storage.MVCCScanResponse.ts)
  return &ts_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace storage
}  // namespace azino

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::azino::storage::StorageStatus_Code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::azino::storage::StorageStatus_Code>() {
  return ::azino::storage::StorageStatus_Code_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_2fstorage_2fstorage_2eproto__INCLUDED
