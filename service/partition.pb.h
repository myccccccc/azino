// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/partition.proto

#ifndef PROTOBUF_service_2fpartition_2eproto__INCLUDED
#define PROTOBUF_service_2fpartition_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace azino {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_service_2fpartition_2eproto();
void protobuf_AssignDesc_service_2fpartition_2eproto();
void protobuf_ShutdownFile_service_2fpartition_2eproto();

class PartitionConfigMapPB;
class PartitionConfigPB;
class PartitionPB;
class RangePB;

// ===================================================================

class RangePB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.RangePB) */ {
 public:
  RangePB();
  virtual ~RangePB();

  RangePB(const RangePB& from);

  inline RangePB& operator=(const RangePB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangePB& default_instance();

  void Swap(RangePB* other);

  // implements Message ----------------------------------------------

  inline RangePB* New() const { return New(NULL); }

  RangePB* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangePB& from);
  void MergeFrom(const RangePB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangePB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  const ::std::string& left() const;
  void set_left(const ::std::string& value);
  void set_left(const char* value);
  void set_left(const char* value, size_t size);
  ::std::string* mutable_left();
  ::std::string* release_left();
  void set_allocated_left(::std::string* left);

  // optional string right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  const ::std::string& right() const;
  void set_right(const ::std::string& value);
  void set_right(const char* value);
  void set_right(const char* value, size_t size);
  ::std::string* mutable_right();
  ::std::string* release_right();
  void set_allocated_right(::std::string* right);

  // optional int32 left_include = 3;
  bool has_left_include() const;
  void clear_left_include();
  static const int kLeftIncludeFieldNumber = 3;
  ::google::protobuf::int32 left_include() const;
  void set_left_include(::google::protobuf::int32 value);

  // optional int32 right_include = 4;
  bool has_right_include() const;
  void clear_right_include();
  static const int kRightIncludeFieldNumber = 4;
  ::google::protobuf::int32 right_include() const;
  void set_right_include(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:azino.RangePB)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_left_include();
  inline void clear_has_left_include();
  inline void set_has_right_include();
  inline void clear_has_right_include();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr left_;
  ::google::protobuf::internal::ArenaStringPtr right_;
  ::google::protobuf::int32 left_include_;
  ::google::protobuf::int32 right_include_;
  friend void  protobuf_AddDesc_service_2fpartition_2eproto();
  friend void protobuf_AssignDesc_service_2fpartition_2eproto();
  friend void protobuf_ShutdownFile_service_2fpartition_2eproto();

  void InitAsDefaultInstance();
  static RangePB* default_instance_;
};
// -------------------------------------------------------------------

class PartitionConfigPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.PartitionConfigPB) */ {
 public:
  PartitionConfigPB();
  virtual ~PartitionConfigPB();

  PartitionConfigPB(const PartitionConfigPB& from);

  inline PartitionConfigPB& operator=(const PartitionConfigPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionConfigPB& default_instance();

  void Swap(PartitionConfigPB* other);

  // implements Message ----------------------------------------------

  inline PartitionConfigPB* New() const { return New(NULL); }

  PartitionConfigPB* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartitionConfigPB& from);
  void MergeFrom(const PartitionConfigPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionConfigPB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txindex = 1;
  bool has_txindex() const;
  void clear_txindex();
  static const int kTxindexFieldNumber = 1;
  const ::std::string& txindex() const;
  void set_txindex(const ::std::string& value);
  void set_txindex(const char* value);
  void set_txindex(const char* value, size_t size);
  ::std::string* mutable_txindex();
  ::std::string* release_txindex();
  void set_allocated_txindex(::std::string* txindex);

  // repeated string pessimism_key = 2;
  int pessimism_key_size() const;
  void clear_pessimism_key();
  static const int kPessimismKeyFieldNumber = 2;
  const ::std::string& pessimism_key(int index) const;
  ::std::string* mutable_pessimism_key(int index);
  void set_pessimism_key(int index, const ::std::string& value);
  void set_pessimism_key(int index, const char* value);
  void set_pessimism_key(int index, const char* value, size_t size);
  ::std::string* add_pessimism_key();
  void add_pessimism_key(const ::std::string& value);
  void add_pessimism_key(const char* value);
  void add_pessimism_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pessimism_key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pessimism_key();

  // @@protoc_insertion_point(class_scope:azino.PartitionConfigPB)
 private:
  inline void set_has_txindex();
  inline void clear_has_txindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr txindex_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pessimism_key_;
  friend void  protobuf_AddDesc_service_2fpartition_2eproto();
  friend void protobuf_AssignDesc_service_2fpartition_2eproto();
  friend void protobuf_ShutdownFile_service_2fpartition_2eproto();

  void InitAsDefaultInstance();
  static PartitionConfigPB* default_instance_;
};
// -------------------------------------------------------------------

class PartitionConfigMapPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.PartitionConfigMapPB) */ {
 public:
  PartitionConfigMapPB();
  virtual ~PartitionConfigMapPB();

  PartitionConfigMapPB(const PartitionConfigMapPB& from);

  inline PartitionConfigMapPB& operator=(const PartitionConfigMapPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionConfigMapPB& default_instance();

  void Swap(PartitionConfigMapPB* other);

  // implements Message ----------------------------------------------

  inline PartitionConfigMapPB* New() const { return New(NULL); }

  PartitionConfigMapPB* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartitionConfigMapPB& from);
  void MergeFrom(const PartitionConfigMapPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionConfigMapPB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .azino.RangePB ranges = 1;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 1;
  const ::azino::RangePB& ranges(int index) const;
  ::azino::RangePB* mutable_ranges(int index);
  ::azino::RangePB* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::azino::RangePB >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::azino::RangePB >&
      ranges() const;

  // repeated .azino.PartitionConfigPB partition_configs = 2;
  int partition_configs_size() const;
  void clear_partition_configs();
  static const int kPartitionConfigsFieldNumber = 2;
  const ::azino::PartitionConfigPB& partition_configs(int index) const;
  ::azino::PartitionConfigPB* mutable_partition_configs(int index);
  ::azino::PartitionConfigPB* add_partition_configs();
  ::google::protobuf::RepeatedPtrField< ::azino::PartitionConfigPB >*
      mutable_partition_configs();
  const ::google::protobuf::RepeatedPtrField< ::azino::PartitionConfigPB >&
      partition_configs() const;

  // @@protoc_insertion_point(class_scope:azino.PartitionConfigMapPB)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::azino::RangePB > ranges_;
  ::google::protobuf::RepeatedPtrField< ::azino::PartitionConfigPB > partition_configs_;
  friend void  protobuf_AddDesc_service_2fpartition_2eproto();
  friend void protobuf_AssignDesc_service_2fpartition_2eproto();
  friend void protobuf_ShutdownFile_service_2fpartition_2eproto();

  void InitAsDefaultInstance();
  static PartitionConfigMapPB* default_instance_;
};
// -------------------------------------------------------------------

class PartitionPB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:azino.PartitionPB) */ {
 public:
  PartitionPB();
  virtual ~PartitionPB();

  PartitionPB(const PartitionPB& from);

  inline PartitionPB& operator=(const PartitionPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionPB& default_instance();

  void Swap(PartitionPB* other);

  // implements Message ----------------------------------------------

  inline PartitionPB* New() const { return New(NULL); }

  PartitionPB* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartitionPB& from);
  void MergeFrom(const PartitionPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionPB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .azino.PartitionConfigMapPB pcm = 1;
  bool has_pcm() const;
  void clear_pcm();
  static const int kPcmFieldNumber = 1;
  const ::azino::PartitionConfigMapPB& pcm() const;
  ::azino::PartitionConfigMapPB* mutable_pcm();
  ::azino::PartitionConfigMapPB* release_pcm();
  void set_allocated_pcm(::azino::PartitionConfigMapPB* pcm);

  // optional string storage = 2;
  bool has_storage() const;
  void clear_storage();
  static const int kStorageFieldNumber = 2;
  const ::std::string& storage() const;
  void set_storage(const ::std::string& value);
  void set_storage(const char* value);
  void set_storage(const char* value, size_t size);
  ::std::string* mutable_storage();
  ::std::string* release_storage();
  void set_allocated_storage(::std::string* storage);

  // @@protoc_insertion_point(class_scope:azino.PartitionPB)
 private:
  inline void set_has_pcm();
  inline void clear_has_pcm();
  inline void set_has_storage();
  inline void clear_has_storage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::azino::PartitionConfigMapPB* pcm_;
  ::google::protobuf::internal::ArenaStringPtr storage_;
  friend void  protobuf_AddDesc_service_2fpartition_2eproto();
  friend void protobuf_AssignDesc_service_2fpartition_2eproto();
  friend void protobuf_ShutdownFile_service_2fpartition_2eproto();

  void InitAsDefaultInstance();
  static PartitionPB* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RangePB

// optional string left = 1;
inline bool RangePB::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangePB::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangePB::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangePB::clear_left() {
  left_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_left();
}
inline const ::std::string& RangePB::left() const {
  // @@protoc_insertion_point(field_get:azino.RangePB.left)
  return left_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangePB::set_left(const ::std::string& value) {
  set_has_left();
  left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.RangePB.left)
}
inline void RangePB::set_left(const char* value) {
  set_has_left();
  left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.RangePB.left)
}
inline void RangePB::set_left(const char* value, size_t size) {
  set_has_left();
  left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.RangePB.left)
}
inline ::std::string* RangePB::mutable_left() {
  set_has_left();
  // @@protoc_insertion_point(field_mutable:azino.RangePB.left)
  return left_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangePB::release_left() {
  // @@protoc_insertion_point(field_release:azino.RangePB.left)
  clear_has_left();
  return left_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangePB::set_allocated_left(::std::string* left) {
  if (left != NULL) {
    set_has_left();
  } else {
    clear_has_left();
  }
  left_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), left);
  // @@protoc_insertion_point(field_set_allocated:azino.RangePB.left)
}

// optional string right = 2;
inline bool RangePB::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangePB::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangePB::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangePB::clear_right() {
  right_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_right();
}
inline const ::std::string& RangePB::right() const {
  // @@protoc_insertion_point(field_get:azino.RangePB.right)
  return right_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangePB::set_right(const ::std::string& value) {
  set_has_right();
  right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.RangePB.right)
}
inline void RangePB::set_right(const char* value) {
  set_has_right();
  right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.RangePB.right)
}
inline void RangePB::set_right(const char* value, size_t size) {
  set_has_right();
  right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.RangePB.right)
}
inline ::std::string* RangePB::mutable_right() {
  set_has_right();
  // @@protoc_insertion_point(field_mutable:azino.RangePB.right)
  return right_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangePB::release_right() {
  // @@protoc_insertion_point(field_release:azino.RangePB.right)
  clear_has_right();
  return right_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangePB::set_allocated_right(::std::string* right) {
  if (right != NULL) {
    set_has_right();
  } else {
    clear_has_right();
  }
  right_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), right);
  // @@protoc_insertion_point(field_set_allocated:azino.RangePB.right)
}

// optional int32 left_include = 3;
inline bool RangePB::has_left_include() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangePB::set_has_left_include() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangePB::clear_has_left_include() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangePB::clear_left_include() {
  left_include_ = 0;
  clear_has_left_include();
}
inline ::google::protobuf::int32 RangePB::left_include() const {
  // @@protoc_insertion_point(field_get:azino.RangePB.left_include)
  return left_include_;
}
inline void RangePB::set_left_include(::google::protobuf::int32 value) {
  set_has_left_include();
  left_include_ = value;
  // @@protoc_insertion_point(field_set:azino.RangePB.left_include)
}

// optional int32 right_include = 4;
inline bool RangePB::has_right_include() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangePB::set_has_right_include() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangePB::clear_has_right_include() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangePB::clear_right_include() {
  right_include_ = 0;
  clear_has_right_include();
}
inline ::google::protobuf::int32 RangePB::right_include() const {
  // @@protoc_insertion_point(field_get:azino.RangePB.right_include)
  return right_include_;
}
inline void RangePB::set_right_include(::google::protobuf::int32 value) {
  set_has_right_include();
  right_include_ = value;
  // @@protoc_insertion_point(field_set:azino.RangePB.right_include)
}

// -------------------------------------------------------------------

// PartitionConfigPB

// optional string txindex = 1;
inline bool PartitionConfigPB::has_txindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionConfigPB::set_has_txindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionConfigPB::clear_has_txindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionConfigPB::clear_txindex() {
  txindex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txindex();
}
inline const ::std::string& PartitionConfigPB::txindex() const {
  // @@protoc_insertion_point(field_get:azino.PartitionConfigPB.txindex)
  return txindex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionConfigPB::set_txindex(const ::std::string& value) {
  set_has_txindex();
  txindex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.PartitionConfigPB.txindex)
}
inline void PartitionConfigPB::set_txindex(const char* value) {
  set_has_txindex();
  txindex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.PartitionConfigPB.txindex)
}
inline void PartitionConfigPB::set_txindex(const char* value, size_t size) {
  set_has_txindex();
  txindex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.PartitionConfigPB.txindex)
}
inline ::std::string* PartitionConfigPB::mutable_txindex() {
  set_has_txindex();
  // @@protoc_insertion_point(field_mutable:azino.PartitionConfigPB.txindex)
  return txindex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionConfigPB::release_txindex() {
  // @@protoc_insertion_point(field_release:azino.PartitionConfigPB.txindex)
  clear_has_txindex();
  return txindex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionConfigPB::set_allocated_txindex(::std::string* txindex) {
  if (txindex != NULL) {
    set_has_txindex();
  } else {
    clear_has_txindex();
  }
  txindex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txindex);
  // @@protoc_insertion_point(field_set_allocated:azino.PartitionConfigPB.txindex)
}

// repeated string pessimism_key = 2;
inline int PartitionConfigPB::pessimism_key_size() const {
  return pessimism_key_.size();
}
inline void PartitionConfigPB::clear_pessimism_key() {
  pessimism_key_.Clear();
}
inline const ::std::string& PartitionConfigPB::pessimism_key(int index) const {
  // @@protoc_insertion_point(field_get:azino.PartitionConfigPB.pessimism_key)
  return pessimism_key_.Get(index);
}
inline ::std::string* PartitionConfigPB::mutable_pessimism_key(int index) {
  // @@protoc_insertion_point(field_mutable:azino.PartitionConfigPB.pessimism_key)
  return pessimism_key_.Mutable(index);
}
inline void PartitionConfigPB::set_pessimism_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:azino.PartitionConfigPB.pessimism_key)
  pessimism_key_.Mutable(index)->assign(value);
}
inline void PartitionConfigPB::set_pessimism_key(int index, const char* value) {
  pessimism_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:azino.PartitionConfigPB.pessimism_key)
}
inline void PartitionConfigPB::set_pessimism_key(int index, const char* value, size_t size) {
  pessimism_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:azino.PartitionConfigPB.pessimism_key)
}
inline ::std::string* PartitionConfigPB::add_pessimism_key() {
  // @@protoc_insertion_point(field_add_mutable:azino.PartitionConfigPB.pessimism_key)
  return pessimism_key_.Add();
}
inline void PartitionConfigPB::add_pessimism_key(const ::std::string& value) {
  pessimism_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:azino.PartitionConfigPB.pessimism_key)
}
inline void PartitionConfigPB::add_pessimism_key(const char* value) {
  pessimism_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:azino.PartitionConfigPB.pessimism_key)
}
inline void PartitionConfigPB::add_pessimism_key(const char* value, size_t size) {
  pessimism_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:azino.PartitionConfigPB.pessimism_key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PartitionConfigPB::pessimism_key() const {
  // @@protoc_insertion_point(field_list:azino.PartitionConfigPB.pessimism_key)
  return pessimism_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PartitionConfigPB::mutable_pessimism_key() {
  // @@protoc_insertion_point(field_mutable_list:azino.PartitionConfigPB.pessimism_key)
  return &pessimism_key_;
}

// -------------------------------------------------------------------

// PartitionConfigMapPB

// repeated .azino.RangePB ranges = 1;
inline int PartitionConfigMapPB::ranges_size() const {
  return ranges_.size();
}
inline void PartitionConfigMapPB::clear_ranges() {
  ranges_.Clear();
}
inline const ::azino::RangePB& PartitionConfigMapPB::ranges(int index) const {
  // @@protoc_insertion_point(field_get:azino.PartitionConfigMapPB.ranges)
  return ranges_.Get(index);
}
inline ::azino::RangePB* PartitionConfigMapPB::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:azino.PartitionConfigMapPB.ranges)
  return ranges_.Mutable(index);
}
inline ::azino::RangePB* PartitionConfigMapPB::add_ranges() {
  // @@protoc_insertion_point(field_add:azino.PartitionConfigMapPB.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::azino::RangePB >*
PartitionConfigMapPB::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:azino.PartitionConfigMapPB.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::azino::RangePB >&
PartitionConfigMapPB::ranges() const {
  // @@protoc_insertion_point(field_list:azino.PartitionConfigMapPB.ranges)
  return ranges_;
}

// repeated .azino.PartitionConfigPB partition_configs = 2;
inline int PartitionConfigMapPB::partition_configs_size() const {
  return partition_configs_.size();
}
inline void PartitionConfigMapPB::clear_partition_configs() {
  partition_configs_.Clear();
}
inline const ::azino::PartitionConfigPB& PartitionConfigMapPB::partition_configs(int index) const {
  // @@protoc_insertion_point(field_get:azino.PartitionConfigMapPB.partition_configs)
  return partition_configs_.Get(index);
}
inline ::azino::PartitionConfigPB* PartitionConfigMapPB::mutable_partition_configs(int index) {
  // @@protoc_insertion_point(field_mutable:azino.PartitionConfigMapPB.partition_configs)
  return partition_configs_.Mutable(index);
}
inline ::azino::PartitionConfigPB* PartitionConfigMapPB::add_partition_configs() {
  // @@protoc_insertion_point(field_add:azino.PartitionConfigMapPB.partition_configs)
  return partition_configs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::azino::PartitionConfigPB >*
PartitionConfigMapPB::mutable_partition_configs() {
  // @@protoc_insertion_point(field_mutable_list:azino.PartitionConfigMapPB.partition_configs)
  return &partition_configs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::azino::PartitionConfigPB >&
PartitionConfigMapPB::partition_configs() const {
  // @@protoc_insertion_point(field_list:azino.PartitionConfigMapPB.partition_configs)
  return partition_configs_;
}

// -------------------------------------------------------------------

// PartitionPB

// optional .azino.PartitionConfigMapPB pcm = 1;
inline bool PartitionPB::has_pcm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionPB::set_has_pcm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionPB::clear_has_pcm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionPB::clear_pcm() {
  if (pcm_ != NULL) pcm_->::azino::PartitionConfigMapPB::Clear();
  clear_has_pcm();
}
inline const ::azino::PartitionConfigMapPB& PartitionPB::pcm() const {
  // @@protoc_insertion_point(field_get:azino.PartitionPB.pcm)
  return pcm_ != NULL ? *pcm_ : *default_instance_->pcm_;
}
inline ::azino::PartitionConfigMapPB* PartitionPB::mutable_pcm() {
  set_has_pcm();
  if (pcm_ == NULL) {
    pcm_ = new ::azino::PartitionConfigMapPB;
  }
  // @@protoc_insertion_point(field_mutable:azino.PartitionPB.pcm)
  return pcm_;
}
inline ::azino::PartitionConfigMapPB* PartitionPB::release_pcm() {
  // @@protoc_insertion_point(field_release:azino.PartitionPB.pcm)
  clear_has_pcm();
  ::azino::PartitionConfigMapPB* temp = pcm_;
  pcm_ = NULL;
  return temp;
}
inline void PartitionPB::set_allocated_pcm(::azino::PartitionConfigMapPB* pcm) {
  delete pcm_;
  pcm_ = pcm;
  if (pcm) {
    set_has_pcm();
  } else {
    clear_has_pcm();
  }
  // @@protoc_insertion_point(field_set_allocated:azino.PartitionPB.pcm)
}

// optional string storage = 2;
inline bool PartitionPB::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionPB::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionPB::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionPB::clear_storage() {
  storage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_storage();
}
inline const ::std::string& PartitionPB::storage() const {
  // @@protoc_insertion_point(field_get:azino.PartitionPB.storage)
  return storage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionPB::set_storage(const ::std::string& value) {
  set_has_storage();
  storage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:azino.PartitionPB.storage)
}
inline void PartitionPB::set_storage(const char* value) {
  set_has_storage();
  storage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:azino.PartitionPB.storage)
}
inline void PartitionPB::set_storage(const char* value, size_t size) {
  set_has_storage();
  storage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:azino.PartitionPB.storage)
}
inline ::std::string* PartitionPB::mutable_storage() {
  set_has_storage();
  // @@protoc_insertion_point(field_mutable:azino.PartitionPB.storage)
  return storage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionPB::release_storage() {
  // @@protoc_insertion_point(field_release:azino.PartitionPB.storage)
  clear_has_storage();
  return storage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionPB::set_allocated_storage(::std::string* storage) {
  if (storage != NULL) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
  storage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storage);
  // @@protoc_insertion_point(field_set_allocated:azino.PartitionPB.storage)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace azino

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_2fpartition_2eproto__INCLUDED
